﻿@using System.Collections.Specialized;
@using System.Diagnostics.CodeAnalysis;
@using System.Linq.Expressions;
@using System.Reflection;
@using System.Text.Json;
@using System.Web;
@using BlazingStory.Components;
@using BlazingStory.Internals.Extensions;
@using BlazingStory.Internals.Models;
@using BlazingStory.Internals.Services;
@using BlazingStory.Internals.Utils;
@using Microsoft.AspNetCore.Components;
@using Microsoft.AspNetCore.Components.Routing;
@using Microsoft.Extensions.Logging;
@using Microsoft.JSInterop;
@using static System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes;

@implements IAsyncDisposable

@{
#pragma warning disable IL2111
}
@if (this._Story == null)
{
    <CanvasFrameNothingToAddress />
}
else
{
    <LayoutView Layout="@(this.BlazingStoryApp.DefaultLayout ?? typeof(NullLayout))">
        <LayoutView Layout="@(this._Story.StoriesLayout ?? typeof(NullLayout))">
            <LayoutView Layout="@(this._Story.StoryLayout ?? typeof(NullLayout))">

                @this._Story.RenderFragment(this._Story.Context)

            </LayoutView>
        </LayoutView>
    </LayoutView>
}
@{
#pragma warning restore IL2111
}

@if (this._EnableMeasure)
{
    <MeasureLayer />
}

@code
{
    /// <summary>
    /// Static semaphore to prevent race conditions when multiple CanvasFrame instances process events simultaneously.
    /// Ensures thread-safe event processing across different story instances.
    /// </summary>
    private static readonly SemaphoreSlim EventProcessingLock = new(1, 1);

    /// <summary>
    /// Flag to suppress event firing during URL-driven property updates.
    /// Prevents cascade effects when updating component properties from URL parameters.
    /// </summary>
    private bool _SuppressEventFiring = false;

    /// <summary>
    /// Gets or sets the stories store containing all available stories and their metadata.
    /// Provides access to story definitions, parameters, and component information.
    /// </summary>
    [CascadingParameter]
    protected StoriesStore StoriesStore { get; init; } = default!;

    /// <summary>
    /// Gets or sets the route data containing URL parameters and navigation information.
    /// Used to determine which story to display based on the current route.
    /// </summary>
    [CascadingParameter]
    protected QueryRouteData RouteData { get; init; } = default!;

    /// <summary>
    /// Gets or sets the main BlazingStory application context.
    /// Provides access to global application state and configuration.
    /// </summary>
    [CascadingParameter]
    protected BlazingStoryApp BlazingStoryApp { get; init; } = default!;

    /// <summary>
    /// Gets or sets the JavaScript runtime for interop operations.
    /// Used for DOM manipulation, event handling, and style injection.
    /// </summary>
    [Inject]
    private IJSRuntime? JSRuntime { get; set; }

    /// <summary>
    /// Gets or sets the logger for recording debug information and errors.
    /// Used for tracking component lifecycle events and troubleshooting issues.
    /// </summary>
    [Inject]
    private ILogger<CanvasFrame>? Logger { get; set; }

    /// <summary>
    /// Gets or sets the navigation manager for URL manipulation and routing.
    /// Used for synchronizing component state with URL parameters.
    /// </summary>
    [Inject]
    private NavigationManager? NavigationManager { get; set; }

    /// <summary>
    /// Lazily-initialized MethodInfo for the EventTArgMonitorHandler method.
    /// Used for creating strongly-typed event callbacks through reflection.
    /// Suppressed code smell as reflection is necessary for generic event handling.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Major Code Smell", "S3011:Reflection should not be used to increase accessibility of classes, methods, or fields", Justification = "Required for dynamic event callback creation")]
    private static readonly Lazy<MethodInfo> _EventTArgMonitorHandlerMethod = new(() => typeof(CanvasFrame).GetMethod(nameof(EventTArgMonitorHandler), BindingFlags.NonPublic | BindingFlags.Instance) ?? throw new InvalidOperationException());

    /// <summary>
    /// Lazily-initialized MethodInfo for the EventCallbackFactory.Create method.
    /// Used for creating EventCallback instances with proper generic type parameters.
    /// Performance optimization to avoid repeated reflection lookups.
    /// </summary>
    private static readonly Lazy<MethodInfo> _EventCallbackCreateMethod = new(() =>
        typeof(EventCallbackFactory).GetMethods(BindingFlags.Public | BindingFlags.Instance)
            .Where(m => m.Name == "Create" && m.IsGenericMethod)
            .Select(m => (MethodInfo: m, ParameterTypes: m.GetParameters().Select(p => p.ParameterType).ToArray()))
            .Where(m => m.ParameterTypes.Length == 2)
            .Where(m => m.ParameterTypes[0] == typeof(object))
            .Where(m => m.ParameterTypes[1].IsGenericType && m.ParameterTypes[1].GetGenericTypeDefinition() == typeof(Func<,>))
            .Select(m => m.MethodInfo)
            .First());

    /// <summary>
    /// JavaScript module wrapper for canvas-specific operations like style injection and event dispatch.
    /// </summary>
    private JSModule? _JSModule;

    /// <summary>
    /// The currently displayed story containing component metadata and parameters.
    /// </summary>
    private Story? _Story;

    /// <summary>
    /// Flag indicating whether measurement tools are enabled for the current story.
    /// </summary>
    private bool _EnableMeasure = false;

    /// <summary>
    /// Flag indicating whether the component has completed its first render cycle.
    /// </summary>
    private bool _Rendered = false;

    /// <summary>
    /// Cached string representation of component arguments for change detection.
    /// </summary>
    private string _ComponentArgsString = string.Empty;

    /// <summary>
    /// Cached string representation of global effects for change detection.
    /// </summary>
    private string _GlobalEffectsString = string.Empty;

    /// <summary>
    /// Asynchronously disposes of all resources used by the CanvasFrame component.
    /// This includes unsubscribing from events, disposing JavaScript modules, and cleaning up references.
    /// </summary>
    public async ValueTask DisposeAsync()
    {
        // Unsubscribe from story context events to prevent memory leaks
        if (this._Story != null)
        {
            this._Story.Context.ShouldRender -= this.StoryContext_ShouldRender;
        }

        // Unsubscribe from navigation events
        if (this.NavigationManager != null)
        {
            this.NavigationManager.LocationChanged -= this.NavigationManager_LocationChanged;
        }

        // Dispose JavaScript module and associated resources
        if (this._JSModule != null)
        {
            await this._JSModule.DisposeAsync();
        }
    }

    /// <summary>
    /// Initializes the component by setting up JavaScript modules and event subscriptions.
    /// Called once when the component is first created.
    /// </summary>
    protected override void OnInitialized()
    {
        // Initialize JavaScript module for canvas-specific operations
        if (this.JSRuntime is not null)
        {
            this._JSModule = new(() => this.JSRuntime, "Internals/Pages/Canvas/CanvasFrame.razor.js");
        }

        // Subscribe to navigation changes to keep URL synchronized with component state
        if (this.NavigationManager != null)
        {
            this.NavigationManager.LocationChanged += this.NavigationManager_LocationChanged;
        }
    }

    /// <summary>
    /// Called whenever component parameters change, updates the displayed story accordingly.
    /// Handles story switching, event subscription management, and component state updates.
    /// </summary>
    protected override async Task OnParametersSetAsync()
    {
        // Try to get the story based on the current route parameter
        if (!this.StoriesStore.TryGetStoryByPath(this.RouteData.Parameter, out var story))
        {
            return; // Exit if story not found
        }

        // Skip processing if the story hasn't actually changed (performance optimization)
        if (Object.ReferenceEquals(this._Story, story))
        {
            return;
        }

        // Unsubscribe from the previous story's events to prevent memory leaks
        if (this._Story != null)
        {
            this._Story.Context.ShouldRender -= this.StoryContext_ShouldRender;
        }

        // Set the new story and subscribe to its events
        this._Story = story;
        this._Story.Context.ShouldRender += this.StoryContext_ShouldRender;

        // Update component states based on URL parameters and wire up event monitoring
        await this.UpdateComponentStatesAsync();
        this.StateHasChanged();
    }

    /// <summary>
    /// Handles post-render operations, particularly setting up the component after first render.
    /// The first render flag ensures JavaScript operations only run after the DOM is ready.
    /// </summary>
    /// <param name="firstRender">True if this is the first time the component has been rendered</param>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        // Mark as rendered to enable JavaScript operations
        this._Rendered = true;

        // Update component states now that the DOM is ready
        await this.UpdateComponentStatesAsync();
        this.StateHasChanged();
    }

    /// <summary>
    /// Event handler for story context render requests.
    /// When the story's state changes, this canvas frame needs to re-render to reflect those changes.
    /// </summary>
    /// <param name="sender">The story context that triggered the event</param>
    /// <param name="e">Event arguments (unused)</param>
    private void StoryContext_ShouldRender(object? sender, EventArgs e)
    {
        // Trigger a re-render of this component
        this.StateHasChanged();
    }

    /// <summary>
    /// Event handler for navigation location changes.
    /// Updates component state when URL parameters change (e.g., through browser navigation).
    /// </summary>
    /// <param name="sender">The NavigationManager that triggered the event</param>
    /// <param name="args">Event arguments containing the new location</param>
    private void NavigationManager_LocationChanged(object? sender, LocationChangedEventArgs args)
    {
        if (this.Logger != null)
        {
            // Update component states asynchronously and log any exceptions
            this.UpdateComponentStatesAsync().AndLogException(this.Logger);
        }
    }

    /// <summary>
    /// Updates all component states based on current URL parameters and story configuration.
    /// This method orchestrates the synchronization between URL state and component state.
    /// </summary>
    private async ValueTask UpdateComponentStatesAsync()
    {
        // Exit if navigation manager is not available
        if (this.NavigationManager == null)
        {
            return;
        }

        // Parse current URL query parameters
        var queryStrings = HttpUtility.ParseQueryString(new Uri(this.NavigationManager.Uri).Query);

        // Update component arguments from URL parameters
        await this.UpdateComponentArgsFromUrlAsync(queryStrings);

        // Apply global effects (themes, backgrounds, etc.)
        await this.UpdateGlobalEffectsFromUrlAsync(queryStrings);

        // Set up event monitoring for two-way binding
        await this.WireUpEventMonitorsAsync();
    }

    /// <summary>
    /// Updates component arguments from URL query parameters, maintaining synchronization between URL and component state.
    /// This method handles the complex process of converting URL parameters back into strongly-typed component properties.
    /// </summary>
    /// <param name="queryStrings">The parsed query string collection from the current URL</param>
    private async ValueTask UpdateComponentArgsFromUrlAsync(NameValueCollection queryStrings)
    {
        // Skip processing if no story is currently loaded
        if (this._Story == null)
        {
            return;
        }

        // Extract and decode the component arguments from the URL
        var componentArgsString = queryStrings["args"] ?? string.Empty;
        componentArgsString = UrlParameterShortener.DecodeAndDecompress(componentArgsString);

        // Performance optimization: skip if arguments haven't changed
        if (this._ComponentArgsString == componentArgsString)
        {
            return;
        }

        // Update our cached version and decode the new arguments
        this._ComponentArgsString = componentArgsString;
        var newComponentArgs = UriParameterKit.DecodeKeyValues(componentArgsString);

        // Count non-EventCallback args in the context (for fair comparison)
        var nonEventCallbackArgsCount = this._Story.Context.Args
            .Count(x => x.Value == null || !x.Value.GetType().Name.StartsWith("EventCallback"));

        var argsMatch = true;
        foreach (var arg in newComponentArgs)
        {
            if (!this._Story.Context.Args.TryGetValue(arg.Key, out var currentValue))
            {
                argsMatch = false;
                break;
            }

            // Convert current value to string using the same method as when writing to URL
            var currentValueString = this._Story.Context.ConvertParameterValueToString(arg.Key, currentValue);
            if (!Equals(currentValueString, arg.Value))
            {
                argsMatch = false;
                break;
            }
        }

        // Compare counts excluding EventCallbacks (they are never in URL)
        if (argsMatch && nonEventCallbackArgsCount == newComponentArgs.Count)
        {
            return;
        }

        // Convert URL args to typed values
        var updatedArgs = new Dictionary<string, object?>();
        var parameters = this._Story.Context.Parameters;

        foreach (var arg in newComponentArgs)
        {
            var parameter = parameters.FirstOrDefault(p => p.Name == arg.Key);
            if (parameter == null)
            {
                continue;
            }
            if (!parameter.TypeStructure.TryConvertType(arg.Value, out var value))
            {
                continue;
            }
            updatedArgs[arg.Key] = value;
        }

        // IMPORTANT: Use UpdateArgumentsAsync instead of ResetAndUpdateArgumentsAsync to avoid
        // visual flash when the component briefly renders with default values

        // CRITICAL: Suppress event firing during URL-driven updates to prevent cascade effects
        this._SuppressEventFiring = true;
        try
        {
            await this._Story.Context.UpdateArgumentsAsync(updatedArgs);
            this.StateHasChanged();

            // Give the DOM time to update properties before re-enabling events
            await Task.Delay(50);
        }
        finally
        {
            this._SuppressEventFiring = false;
        }
    }

    /// <summary>
    /// Updates the browser URL with current component arguments, maintaining URL-state synchronization.
    /// This method ensures that component state changes are reflected in the URL for sharing and bookmarking.
    /// </summary>
    private async Task UpdateUrlWithArgsAsync()
    {
        // Skip if essential dependencies are not available
        if (this._Story == null || this.NavigationManager == null) return;

        // CRITICAL: Filter out EventCallbacks - they cannot and should not be serialized to URLs
        // EventCallbacks are .NET objects that have no meaningful URL representation
        var args = this._Story.Context.Args
            .Where(x => x.Value == null || !x.Value.GetType().Name.StartsWith("EventCallback"))
            .ToDictionary(
                keySelector: x => x.Key,
                elementSelector: x => (object?)this._Story.Context.ConvertParameterValueToString(x.Key, x.Value)
            );

        // Immediate URL update (no debouncing) to prevent race conditions
        // This ensures LocationChanged events see the updated URL immediately
        var queryStrings = HttpUtility.ParseQueryString(new Uri(this.NavigationManager.Uri).Query);
        var encodedArgs = UriParameterKit.EncodeKeyValues(args);
        var compressedArgs = UrlParameterShortener.CompressAndEncode(encodedArgs);
        queryStrings["args"] = compressedArgs;
        var newUri = new Uri(this.NavigationManager.Uri).GetLeftPart(UriPartial.Path) + "?" + queryStrings.ToString();
        this.NavigationManager.NavigateTo(newUri);

        await Task.CompletedTask;
    }

    /// <summary>
    /// Updates global visual effects and themes based on URL parameters.
    /// This method applies global settings like backgrounds, themes, grids, and measurement tools to the canvas.
    /// </summary>
    /// <param name="queryStrings">The parsed query string collection containing global effect parameters</param>
    private async ValueTask UpdateGlobalEffectsFromUrlAsync(NameValueCollection queryStrings)
    {
        // Skip during server-side pre-rendering as JavaScript operations are not available
        if (!this._Rendered) return;

        // Extract global effects string from URL parameters
        var globalEffectsString = queryStrings["globals"] ?? string.Empty;

        // Performance optimization: skip if global effects haven't changed
        if (this._GlobalEffectsString == globalEffectsString) return;
        this._GlobalEffectsString = globalEffectsString;

        // Decode global effects from URL parameters
        var globalEffects = UriParameterKit.DecodeKeyValues(globalEffectsString);

        // Extract background settings (color, image, etc.)
        var background = globalEffects.TryGetValue("backgrounds.value", out var backgroundStr) ? backgroundStr : "transparent";

        // Extract grid visibility setting for design alignment aids
        var enableGrid = globalEffects.TryGetValue("backgrounds.grid", out var gridStr) ? bool.TryParse(gridStr, out var grid) ? grid : false : false;

        // Extract outline visibility setting for component boundary visualization
        var enableOutline = globalEffects.TryGetValue("outline", out var outlineStr) ? bool.TryParse(outlineStr, out var outline) ? outline : false : false;

        // Extract theme and branding settings
        var theme = globalEffects.TryGetValue("theme.value", out var themeStr) ? themeStr : string.Empty;
        var brand = globalEffects.TryGetValue("brand.value", out var brandStr) ? brandStr : string.Empty;

        // Extract measurement tools setting for development debugging
        this._EnableMeasure = globalEffects.TryGetValue("measureEnabled", out var measureStr) ? bool.TryParse(measureStr, out var measure) ? measure : false : false;

        // Configure CSS resources for visual addons
        var basePath = "./_content/BlazingStory/css/preview/";
        var styleDescripters = new StyleDescriptor[] {
            new() { Id = "addon-background-grid", Enable = enableGrid, Href = basePath + "background-grid.min.css" },
            new() { Id = "addon-outline", Enable = enableOutline, Href = basePath + "outline.min.css" }
        };

        // Apply the global effects through JavaScript interop
        if (this._JSModule != null)
        {
            await this._JSModule.InvokeVoidAsync("ensurePreviewStyle", new object[] { background, styleDescripters, theme, brand });
        }

        // Trigger re-render to apply any component-level changes
        this.StateHasChanged();
    }

    /// <summary>
    /// Sets up event monitoring for all component parameters, enabling two-way data binding.
    /// This method creates EventCallback instances for both void and generic event handlers,
    /// using reflection to handle strongly-typed event arguments.
    /// </summary>
    private async ValueTask WireUpEventMonitorsAsync()
    {
        // Skip if story or parameters are not available
        if (this._Story?.Context?.Parameters == null)
        {
            return;
        }

        // Phase 1: Validate two-way binding patterns for all EventCallback parameters
        // This ensures proper component configuration before setting up event handlers
        var eventCallbackParameters = this._Story.Context.Parameters
            .Where(p => p.Type.IsAssignableTo(typeof(EventCallback)) ||
                       (p.Type.IsGenericType && p.Type.GetGenericTypeDefinition() == typeof(EventCallback<>)))
            .ToList();

        // Validate each event callback that follows the "Changed" naming convention
        foreach (var eventParam in eventCallbackParameters)
        {
            if (eventParam.Name.EndsWith("Changed"))
            {
                // Ensure corresponding property exists and types are compatible
                EventArgumentsProcessor.ValidateTwoWayBindingPattern(eventParam.Name, this._Story, "CanvasFrame");
            }
        }

        // Phase 2: Wire up event callbacks for all parameters
        foreach (var parameter in this._Story.Context.Parameters)
        {
            // Handle void EventCallbacks (events without arguments)
            if (parameter.Type.IsAssignableTo(typeof(EventCallback)))
            {
                // Create a simple event callback that just logs the event name
                var eventCallback = EventCallback.Factory.Create(this, (Func<Task>)(() => this.EventVoidMonitorHandler(parameter.Name)));
                await this._Story.Context.AddOrUpdateArgumentAsync(parameter.Name, eventCallback);
            }
            // Handle generic EventCallback<T> (events with strongly-typed arguments)
            else if (parameter.Type.IsGenericType && parameter.Type.GetGenericTypeDefinition() == typeof(EventCallback<>))
            {
                // Extract the generic type argument (the event argument type)
                var typeOfArgs = parameter.Type.GenericTypeArguments.First();

                if (typeOfArgs == null)
                {
                    continue; // Skip if type information is missing
                }

                // Build a lambda expression for the strongly-typed event handler
                var eventArgsParam = Expression.Parameter(typeOfArgs, "eventArgs");

#pragma warning disable IL2060 // Reflection is necessary for generic event handling
                // Create a generic version of EventTArgMonitorHandler for this specific type
                var monitorHandler = _EventTArgMonitorHandlerMethod.Value.MakeGenericMethod(typeOfArgs);
#pragma warning restore IL2060

                // Build the method call: this.EventTArgMonitorHandler<T>(parameter.Name, eventArgs)
                var callBody = Expression.Call(Expression.Constant(this), monitorHandler, Expression.Constant(parameter.Name), eventArgsParam);

                // Create the lambda: (eventArgs) => this.EventTArgMonitorHandler<T>(parameter.Name, eventArgs)
                var monitorHandlerLambdaType = typeof(Func<,>).MakeGenericType(typeOfArgs, typeof(Task));
                var monitorHandlerLambda = Expression.Lambda(monitorHandlerLambdaType, callBody, eventArgsParam);
                var monitorHandlerDelegate = monitorHandlerLambda.Compile();

#pragma warning disable IL2060 // Reflection is necessary for EventCallback creation
                // Create the EventCallback<T> using the compiled delegate
                var eventCallbackCreate = _EventCallbackCreateMethod.Value.MakeGenericMethod(typeOfArgs) ?? throw new InvalidOperationException();
#pragma warning restore IL2060

                // Invoke EventCallback.Factory.Create<T>(this, delegate) and add to story context
                var eventCallback = eventCallbackCreate.Invoke(EventCallback.Factory, new object[] { this, monitorHandlerDelegate });
                await this._Story.Context.AddOrUpdateArgumentAsync(parameter.Name, eventCallback);
            }
        }
    }

    /// <summary>
    /// Handles void EventCallback events by dispatching them through JavaScript for logging and monitoring.
    /// This method is called for events that don't carry any data (simple button clicks, etc.).
    /// </summary>
    /// <param name="name">The name of the event that was triggered</param>
    private async Task EventVoidMonitorHandler(string name)
    {
        if (this._JSModule != null)
        {
            // Dispatch the event through JavaScript for external monitoring
            await this._JSModule.InvokeVoidAsync("dispatchComponentActionEvent", name, "void");
        }
    }

    /// <summary>
    /// Handles strongly-typed EventCallback&lt;T&gt; events, processing the event arguments for two-way binding.
    /// This method is the core of the two-way binding system, converting component events back into parameter updates.
    /// </summary>
    /// <typeparam name="TArgs">The type of the event arguments</typeparam>
    /// <param name="name">The name of the event that was triggered</param>
    /// <param name="eventArgs">The strongly-typed event arguments containing the new values</param>
    private async Task EventTArgMonitorHandler<[DynamicallyAccessedMembers(PublicProperties)] TArgs>(string name, TArgs eventArgs)
    {
        // Get story identifier for logging context
        var storyId = this._Story?.NavigationPath ?? "Unknown";

        // Skip processing if essential dependencies are not available
        if (this._JSModule == null || this._Story == null)
        {
            return;
        }

        // CRITICAL: Prevent event processing during URL-driven updates to avoid infinite loops
        // When we update component properties from URL changes, we don't want those changes to trigger more URL updates
        if (this._SuppressEventFiring)
        {
            return;
        }

        // PRODUCTION: Intelligent event filtering to prevent cross-story contamination and redundant updates
        // This system ensures events only process when they result in meaningful state changes for the current story
        await EventProcessingLock.WaitAsync();
        try
        {
            // Step 1: Validate proper two-way binding pattern before processing
            if (!EventArgumentsProcessor.ValidateTwoWayBindingPattern(name, this._Story, $"CanvasFrame[{storyId}]"))
            {
                return; // Skip events that don't follow proper two-way binding conventions
            }

            // Step 2: Extract parameter information from the event
            var paramName = EventArgumentsProcessor.MapEventNameToParameterName(name);
            var parameter = EventArgumentsProcessor.FindParameter(paramName, this._Story);
            if (parameter == null)
            {
                return; // Skip if the parameter doesn't exist in this story
            }

            // Step 3: Extract and convert the new value from event arguments
            var expectedType = parameter.TypeStructure.PrimaryType;
            var value = EventArgumentsProcessor.ExtractParameterValue(eventArgs, paramName, expectedType);

            // Step 4: INTELLIGENT FILTERING - Only proceed if the value has actually changed
            // This prevents redundant updates and cross-story event contamination
            var currentValue = this._Story.Context.Args.ContainsKey(paramName) ? this._Story.Context.Args[paramName] : null;
            var currentValueJson = System.Text.Json.JsonSerializer.Serialize(currentValue);
            var newValueJson = System.Text.Json.JsonSerializer.Serialize(value);

            if (currentValueJson == newValueJson)
            {
                return; // Skip processing if the value hasn't actually changed
            }

            // Step 5: Serialize the event for external monitoring and logging
            var json = JsonFallbackSerializer.Serialize(new Dictionary<string, object?> { { paramName, value } });
            await this._JSModule.InvokeVoidAsync("dispatchComponentActionEvent", name, json);

            // Step 6: Update the story context with the new parameter value
            if (this._Story != null)
            {
                await this._Story.Context.AddOrUpdateArgumentAsync(paramName, value);

                // Step 7: Synchronize the URL to reflect the new component state
                await this.UpdateUrlWithArgsAsync();

                // KEEP this log - it's valuable for debugging two-way binding in production
                Console.WriteLine($"CanvasFrame[{storyId}]: EventTArgMonitorHandler - Successfully processed event '{name}' -> parameter '{paramName}'");
            }
        }
        finally
        {
            EventProcessingLock.Release();
        }
    }

    /// <summary>
    /// Represents a CSS style sheet descriptor for conditional loading in the BlazingStory canvas. Used
    /// to manage addon stylesheets like background grids, component outlines, and theme styles.
    /// </summary>
    internal class StyleDescriptor
    {
        /// <summary>
        /// Gets or sets the unique identifier for this style descriptor. Used to prevent duplicate
        /// style loading and enable style toggling.
        /// </summary>
        /// <value>
        /// A unique string identifier for the stylesheet (e.g., "addon-background-grid", "addon-outline").
        /// </value>
        public string? Id { get; init; }

        /// <summary>
        /// Gets or sets whether this stylesheet should be enabled/loaded. Controls conditional loading
        /// based on user preferences and global settings.
        /// </summary>
        /// <value>
        /// true if the stylesheet should be loaded and applied; false to remove or skip loading.
        /// </value>
        public bool Enable { get; init; }

        /// <summary>
        /// Gets or sets the URL/path to the CSS stylesheet file. Should be a valid URL or relative path
        /// to the stylesheet resource.
        /// </summary>
        /// <value>
        /// The URL or path to the CSS file (e.g., "./_content/BlazingStory/css/preview/background-grid.min.css").
        /// </value>
        public string? Href { get; init; }
    }
}